---
layout: post
category: JVM
title: JVM 类加载机制
tagline: by 城南书客
tags: 
  - JVM
published: true
---
## 加载步骤
JVM 类加载机制分为五个部分：加载，验证，准备，解析，初始化

加载：该阶段会在内存中生成一个代表这个类的 java.lang.Class 对象， 作为方法区这个类的各种数据的入口。加载信息可以从class文件、jar 包、war 包中读取，也可以在运行时计算生成（动态代理），还可以由其它文件生成（比如将 JSP 文件转换成对应的 Class 类）。

验证：该阶段是为了确保 class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

准备：该阶段正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。

解析：该阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。

初始化：该阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由 JVM 主导，到了初始阶段，才开始真正执行类中定义的 Java 程序代码。

![](/assets/images/articles/classloader.jpg)
## 类加载器的种类
启动类加载器(Bootstrap ClassLoader)
负责加载 JAVA_HOME\lib 目录中的， 或通过-Xbootclasspath 参数指定路径中的， 且被虚拟机认可（ 按文件名识别， 如 rt.jar） 的类。

扩展类加载器(Extension ClassLoader)
负责加载 JAVA_HOME\lib\ext 目录中的，或通过 java.ext.dirs 系统变量指定路径中的类库。

应用程序类加载器(Application ClassLoader)
负责加载用户路径（ classpath）上的类库。
## 双亲委派
什么是双亲委派？

当一个类收到了类加载请求，他首先把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的class）， 子类加载器才会尝试自己去加载。

有什么作用？

保证了使用不同的类加载器最终得到的都是同样一个 Object 对象，保证了一个类在内存中只被加载一次，避免类的重复加载。